local Config = {;REFERENCE_REFRESH_DELAY = 60000;};return Config;local Cache = {};function Cache:__init();self.m_cache = setmetatable({}, { __mode = "v" });end;function Cache:Add(indexOrId, adapter);self.m_cache[indexOrId] = adapter;end;function Cache:Get(idOrIndex);local adapter = self.m_cache[idOrIndex];if not adapter then;error("no adapter found with idOrIndex: " .. idOrIndex);end;return adapter;end;function Cache:TryGet(idOrIndex, outAdapter);local adapter = self.m_cache[idOrIndex];if not adapter then;return false;end;outAdapter.Value = adapter;return true;end;return Utils.Class.CreateClass(Cache, "Adapter.Cache");local Event = require('Core.Event');local LogLevelToName = {;	[1] = "Trace",;	[2] = "Debug",;	[3] = "Info",;	[4] = "Warning",;	[5] = "Error",;	[6] = "Fatal",;	[10] = "Write";};local Logger = {};local function tableToLineTree(node, maxLevel, properties, level, padding);	padding = padding or ' ';	maxLevel = maxLevel or 5;	level = level or 1;	local lines = {};	if type(node) == 'table' and not Utils.Class.IsClass(node) then;		local keys = {};		if type(properties) == 'string' then;			local propSet = {};			for p in string.gmatch(properties, '%b{}') do;				local propName = string.sub(p, 2, -2);				for k in string.gmatch(propName, '[^,%s]+') do;					propSet[k] = true;				end;			end;			for k in next, node, nil do;				if propSet[k] then;					keys[#keys + 1] = k;				end;			end;		else;			for k in next, node, nil do;				if not properties or properties[k] then;					keys[#keys + 1] = k;				end;			end;		end;		for i, k in ipairs(keys) do;			local line = '';			if i == #keys then;				line = padding .. '└── ' .. tostring(k);			else;				line = padding .. '├── ' .. tostring(k);			end;			table.insert(lines, line);			if level < maxLevel then;;				local childLines = tableToLineTree(node[k], maxLevel, properties, level + 1,;					padding .. (i == #keys and '' or '│ '));				for _, l in ipairs(childLines) do;					table.insert(lines, l);				end;			elseif i == #keys then;				table.insert(lines, padding .. '└── ...');			end;		end;	else;		table.insert(lines, padding .. tostring(node));	end;	return lines;end;function Logger:__init(name, logLevel, onLog, onClear);	self.m_logLevel = logLevel;	self.Name = (string.gsub(name, ' ', '_') or '');	self.OnLog = onLog or Event();	self.OnClear = onClear or Event();end;function Logger:subLogger(name);	name = self.Name .. '.' .. name;	local logger = Logger(name, self.m_logLevel);	return self:CopyListenersTo(logger);end;function Logger:CopyListenersTo(logger);	self.OnLog:CopyTo(logger.OnLog);	self.OnClear:CopyTo(logger.OnClear);	return logger;end;local function formatMessagePart(obj);	if obj == nil then;		return "nil";	end;	if type(obj) == "table" then;		if Utils.Class.IsClass(obj) then;			return tostring(obj);		end;		local str = tostring(obj);		for _, line in ipairs(tableToLineTree(obj)) do;			str = str .. "\n" .. line;		end;		return str;	end;	return tostring(obj);end;local function formatMessage(...);	local messages = { ... };	if #messages == 0 then;		return;	end;	local message = "";	for i, messagePart in pairs(messages) do;		if i == 1 then;			message = formatMessagePart(messagePart);		else;			message = message .. "\n" .. formatMessagePart(messagePart);		end;	end;	return message;end;function Logger:Log(logLevel, ...);	if logLevel < self.m_logLevel then;		return;	end;	local message = formatMessage(...);	if not message then;		return;	end;	if logLevel ~= 10 then;		message = ({ computer.magicTime() })[2] .. " [" .. LogLevelToName[logLevel] .. "]: " .. self.Name .. "\n";			.. "" .. message:gsub("\n", "\n");	else;		message = message:gsub("\n", "\n"):gsub("\r", "\n");	end;	self.OnLog:Trigger(nil, message);end;function Logger:LogTable(t, logLevel, maxLevel, properties);	if logLevel < self.m_logLevel then;		return;	end;	if t == nil or type(t) ~= 'table' then;		return;	end;	local str = "";	for _, line in ipairs(tableToLineTree(t, maxLevel, properties)) do;		str = str .. "\n" .. line;	end;	self:Log(logLevel, str);end;function Logger:Clear();	self.OnClear:Trigger();end;function Logger:FreeLine(logLevel);	if logLevel < self.m_logLevel then;		return;	end;	self.OnLog:Trigger(self, '');end;function Logger:LogTrace(...);	self:Log(1, ...);end;function Logger:LogDebug(...);	self:Log(2, ...);end;function Logger:LogInfo(...);	self:Log(3, ...);end;function Logger:LogWarning(...);	self:Log(4, ...);end;function Logger:LogError(...);	self:Log(5, ...);end;function Logger:LogFatal(...);	self:Log(6, ...);end;function Logger:LogWrite(...);	self:Log(10, ...);end;return Utils.Class.CreateClass(Logger, 'Core.Common.Logger');local Task = {};function Task:__init(func, ...);self.m_func = func;local passthrough = { ... };local count = #passthrough;if count > 16 then;error("cannot pass more than 16 arguments");end;if count > 0 then;self.m_passthrough = passthrough;end;self.m_closed = false;self.m_success = true;self.m_results = {};end;function Task:IsSuccess();return self.m_success;end;function Task:GetResults();return table.unpack(self.m_results);end;function Task:GetResultsArray();return self.m_results;end;function Task:GetTraceback();return self:Traceback();end;local function createInvokeFunc(length);local funcStart = "return function(func, tbl, ...)\nreturn func(\n";local parameter = "tbl[%d],\n";local funcEnd = "...)\nend";local newFunc = funcStart;for i = 1, length, 1 do;newFunc = newFunc .. string.format(parameter, i);end;newFunc = newFunc .. funcEnd;local createFunc = load(newFunc);if not createFunc then;error("unable to create func");end;return createFunc();end;function Task:Execute(...);local function invokeFunc(func, passthrough, ...);if passthrough ~= nil then;local invoke = createInvokeFunc(#passthrough);return { invoke(func, passthrough, ...) };else;return { self.m_func(...) };end;end;self.m_thread = coroutine.create(invokeFunc);self.m_closed = false;self.m_traceback = nil;local success, results = coroutine.resume(self.m_thread, self.m_func, self.m_passthrough, ...);self.m_success = success;if success then;self.m_results = results;else;self.m_error = results;end;return table.unpack(self.m_results);end;function Task:CheckThreadState();local state = self:State();if state == "not created" then;error("cannot resume a not started task");end;if self.m_closed then;error("cannot resume a closed task");end;if state == "running" then;error("cannot resume running task");end;if state == "dead" then;error("cannot resume dead task");end;end;function Task:Resume(...);self:CheckThreadState();self.m_success, self.m_error = coroutine.resume(self.m_thread, ...);return table.unpack(self.m_results);end;function Task:Close();if self.m_closed then return end;if not self.m_success then;self:Traceback(false);end;coroutine.close(self.m_thread);self.m_closed = true;end;function Task:Traceback(all);if self.m_traceback ~= nil or self.m_closed then;return self.m_traceback;end;self.m_traceback = debug.traceback(self.m_thread, self.m_error or "") .. "\n[THREAD START]";if all then;self.m_traceback = self.m_traceback .. "\n" .. debug.traceback():sub(18);end;return self.m_traceback;end;function Task:State();if self.m_thread == nil then;return "not created";end;return coroutine.status(self.m_thread);;end;function Task:LogError(logger, all);self:Close();if not self.m_success and logger then;logger:LogError("Task [Error]:\n" .. self:Traceback(all));end;end;return Utils.Class.CreateClass(Task, "Core.Common.Task");local math = math;local string = string;local UUID = {};UUID.Static__GeneratedCount = 1;UUID.Static__TemplateRegex = "......%-....%-........";local function generateRandomChars(amount);local chars = {};for i = 1, amount, 1 do;local j = math.random(1, 3);if j == 1 then;chars[i] = math.random(48, 57);elseif j == 2 then;chars[i] = math.random(65, 90);elseif j == 3 then;chars[i] = math.random(97, 122);end;end;return chars;end;function UUID.Static__New();math.randomseed(math.floor(computer.time()) + UUID.Static__GeneratedCount);local head = generateRandomChars(6);local body = generateRandomChars(4);local tail = generateRandomChars(8);return UUID(head, body, tail);end;UUID.Static__Empty = Utils.Class.Placeholder;local function convertStringToCharArray(str);return { string.byte(str, 1, str:len()) };end;local function parse(str);local splittedStr = Utils.String.Split(str, "-");local head = convertStringToCharArray(splittedStr[1]);local body = convertStringToCharArray(splittedStr[2]);local tail = convertStringToCharArray(splittedStr[3]);return head, body, tail;end;function UUID.Static__Parse(str);if not str:find(UUID.Static__TemplateRegex) then;return nil;end;return UUID(parse(str));end;function UUID:__init(headOrString, body, tail);if type(headOrString) == "string" then;headOrString, body, tail = parse(headOrString);end;self:Raw__ModifyBehavior({ DisableCustomIndexing = true });self.m_head = headOrString;self.m_body = body;self.m_tail = tail;self:Raw__ModifyBehavior({ DisableCustomIndexing = false });end;function UUID:Equals(other);for i, char in ipairs(self.m_head) do;if char ~= other.m_head[i] then;return false;end;end;for i, char in ipairs(self.m_body) do;if char ~= other.m_body[i] then;return false;end;end;for i, char in ipairs(self.m_tail) do;if char ~= other.m_tail[i] then;return false;end;end;return true;end;function UUID:ToString();local str = "";for _, char in ipairs(self.m_head) do;str = str .. string.char(char);end;str = str .. "-";for _, char in ipairs(self.m_body) do;str = str .. string.char(char);end;str = str .. "-";for _, char in ipairs(self.m_tail) do;str = str .. string.char(char);end;return str;end;function UUID:Serialize();return self:ToString();end;function UUID:__newindex();error("Core.UUID is completely read only", 3);end;function UUID:__tostring();return self:ToString();end;Utils.Class.CreateClass(UUID, 'Core.Common.UUID', require("Core.Json.Serializable"));local empty = {};local splittedTemplate = Utils.String.Split(UUID.Static__TemplateRegex, "%-");for index, splittedTemplatePart in pairs(splittedTemplate) do;empty[index] = {};for _ in string.gmatch(splittedTemplatePart, ".") do;table.insert(empty[index], 48);end;end;UUID.Static__Empty = UUID(table.unpack(empty));return UUID;local Event = require("Core.Event");local Watchable = {};function Watchable:__init(onSetup, onClose);self.m_Event = Event();self.m_IsSetup = false;self.m_OnSetup = onSetup;self.m_OnClose = onClose;end;function Watchable:Count();return self.m_Event:Count();end;function Watchable:Check(onlyClose);local count = self.m_Event:Count();if count > 0 and not self.m_IsSetup and self.m_OnSetup and not onlyClose then;self.m_OnSetup(self);self.m_IsSetup = true;return;end;if count == 0 and self.m_IsSetup and self.m_OnClose then;self.m_OnClose(self);self.m_IsSetup = false;return;end;end;function Watchable:AddTask(task);self.m_Event:AddTask(task);self:Check();return self;end;function Watchable:AddTaskOnce(task);self.m_Event:AddTaskOnce(task);self:Check();return self;end;function Watchable:AddListener(func, ...);self.m_Event:AddListener(func, ...);self:Check();return self;end;function Watchable:AddListenerOnce(func, ...);self.m_Event:AddListenerOnce(func, ...);self:Check();return self;end;function Watchable:Trigger(logger, ...);self.m_Event:Trigger(logger, ...);self:Check(true);end;return Utils.Class.CreateClass(Watchable, "Core.Common.Watchable");local Task = require("Core.Common.Task");local Event = require('Core.Event');local EventPullAdapter = {};function EventPullAdapter:onEventPull(eventPullData);	local eventName = eventPullData[1];	local allEvent = self.m_events["*"];	if allEvent then;		allEvent:Trigger(self.m_logger, eventPullData);		if allEvent:Count() == 0 then;			self.m_events["*"] = nil;		end;	end;	local event = self.m_events[eventName];	if not event then;		return;	end;	event:Trigger(self.m_logger, eventPullData);	if event:Count() == 0 then;		self.m_events[eventName] = nil;	end;end;function EventPullAdapter:Initialize(logger);	self.m_events = {};	self.m_logger = logger;	self.OnEventPull = Event();	return self;end;function EventPullAdapter:GetEvent(signalName);	local event = self.m_events[signalName];	if event then;		return event;	end;	event = Event();	self.m_events[signalName] = event;	return event;end;function EventPullAdapter:AddTask(signalName, task);	local event = self:GetEvent(signalName);	return event:AddTask(task);end;function EventPullAdapter:AddTaskOnce(signalName, task);	local event = self:GetEvent(signalName);	return event:AddTaskOnce(task);end;function EventPullAdapter:AddListener(signalName, listener, ...);	return self:AddTask(signalName, Task(listener, ...));end;function EventPullAdapter:AddListenerOnce(signalName, listener, ...);	return self:AddTaskOnce(signalName, Task(listener, ...));end;function EventPullAdapter:Remove(signalName, index);	local event = self.m_events[signalName];	if not event then;		return;	end;	event:Remove(index);end;function EventPullAdapter:Wait(timeoutSeconds);	self.m_logger:LogTrace('## waiting for event pull ##');;	local eventPullData = nil;	if timeoutSeconds == nil then;		eventPullData = { event.pull() };	else;		eventPullData = { event.pull(timeoutSeconds) };	end;	if #eventPullData == 0 then;		return false;	end;	self.m_logger:LogDebug("event with signalName: '";		.. eventPullData[1] .. "' was received from component: ";		.. tostring(eventPullData[2]));	self.OnEventPull:Trigger(self.m_logger, eventPullData);	self:onEventPull(eventPullData);	return true;end;function EventPullAdapter:WaitForAll(timeoutSeconds);	while self:Wait(timeoutSeconds) do;	end;end;function EventPullAdapter:Run();	self.m_logger:LogDebug('## started event pull loop ##');	while true do;		self:Wait();	end;end;return EventPullAdapter;local Task = require("Core.Common.Task");local Event = {};function Event:__init();self.m_funcs = {};self.m_onceFuncs = {};end;function Event:Count();return #self.m_funcs + #self.m_onceFuncs;end;function Event:AddTask(task);table.insert(self.m_funcs, task);return #self.m_funcs;end;function Event:AddTaskOnce(task);table.insert(self.m_onceFuncs, task);return #self.m_onceFuncs;end;function Event:AddListener(func, ...);return self:AddTask(Task(func, ...));end;function Event:AddListenerOnce(func, ...);return self:AddTaskOnce(Task(func, ...));end;function Event:Remove(index);table.remove(self.m_funcs, index);end;function Event:RemoveOnce(index);table.remove(self.m_onceFuncs, index);end;function Event:Trigger(logger, ...);for _, task in ipairs(self.m_funcs) do;task:Execute(...);task:Close();task:LogError(logger);end;for _, task in ipairs(self.m_onceFuncs) do;task:Execute(...);task:Close();task:LogError(logger);end;self.m_onceFuncs = {};end;function Event:Listeners();local permanentTask = {};for _, task in ipairs(self.m_funcs) do;table.insert(permanentTask, task);end;local onceTask = {};for _, task in ipairs(self.m_onceFuncs) do;table.insert(onceTask, task);end;return {;Permanent = permanentTask,;Once = onceTask;};end;function Event:CopyTo(event);for _, listener in ipairs(self.m_funcs) do;event:AddTask(listener);end;for _, listener in ipairs(self.m_onceFuncs) do;event:AddTaskOnce(listener);end;return event;end;return Utils.Class.CreateClass(Event, "Core.Event");local Path = require("Core.FileSystem.Path");local File = {};function File.Static__WriteAll(path, data);if type(path) == "string" then;path = Path(path);end;if not filesystem.exists(path:GetParentFolder()) then;error("parent folder does not exist: " .. path:GetParentFolder());end;local file = filesystem.open(path:GetPath(), "w");file:write(data);file:close();end;function File.Static__ReadAll(path);if type(path) == "string" then;path = Path(path);end;if not filesystem.exists(path:GetPath()) then;error("file does not exist: " .. path:GetParentFolder());end;local file = filesystem.open(path:GetPath(), "r");local str = "";while true do;local buf = file:read(8192);if not buf then;break;end;str = str .. buf;end;file:close();return str;end;function File:__init(path);if type(path) == "string" then;self.m_path = Path(path);return;end;self.m_path = path;end;function File:GetPath();return self.m_path:GetPath();end;function File:Exists();return filesystem.exists(self.m_path:GetPath());end;function File:IsOpen();if not self.m_file then;return false;end;return true;end;function File:CheckState();if not self:IsOpen() then;error("file is not open: " .. self.m_path:GetPath(), 3);end;end;function File:Open(mode);local file;if not filesystem.exists(self.m_path:GetPath()) then;local parentFolder = self.m_path:GetParentFolder();if not filesystem.exists(parentFolder) then;error("parent folder does not exist: " .. parentFolder);end;if mode == "r" then;file = filesystem.open(self.m_path:GetPath(), "w");file:write("");file:close();file = nil;end;return false;end;self.m_file = filesystem.open(self.m_path:GetPath(), mode);self.m_mode = mode;return true;end;function File:Write(data);self:CheckState();self.m_file:write(data);end;function File:Read(length);self:CheckState();return self.m_file:read(length);end;function File:Seek(mode, offset);self:CheckState();self.m_file:seek(mode, offset);end;function File:Close();self.m_file:close();self.m_file = nil;end;function File:Clear();local isOpen = self:IsOpen();if isOpen then;self:Close();end;if not filesystem.exists(self.m_path:GetPath()) then;return;end;filesystem.remove(self.m_path:GetPath());local file = filesystem.open(self.m_path:GetPath(), "w");file:write("");file:close();if isOpen then;self.m_file = filesystem.open(self.m_path:GetPath(), self.m_mode);end;end;return Utils.Class.CreateClass(File, "Core.FileSystem.File");local function formatStr(str);str = str:gsub("\\", "/");return str;end;local Path = {};function Path.Static__IsNode(str);if str:find("/") then;return false;end;return true;end;function Path:__init(pathOrNodes);if not pathOrNodes then;self.m_nodes = {};return;end;if type(pathOrNodes) == "string" then;pathOrNodes = formatStr(pathOrNodes);pathOrNodes = Utils.String.Split(pathOrNodes, "/");end;local length = #pathOrNodes;local node = pathOrNodes[length];if node ~= "" and not node:find("^.+%..+$") then;pathOrNodes[length + 1] = "";end;self.m_nodes = pathOrNodes;self:Normalize();end;function Path:GetPath();return Utils.String.Join(self.m_nodes, "/");end;Path.__tostring = Path.GetPath;function Path:IsEmpty();return #self.m_nodes == 0 or (#self.m_nodes == 2 and self.m_nodes[1] == "" and self.m_nodes[2] == "");end;function Path:IsFile();return self.m_nodes[#self.m_nodes] ~= "";end;function Path:IsDir();return self.m_nodes[#self.m_nodes] == "";end;function Path:Exists();local path = self:GetPath();return filesystem.exists(path);end;function Path:GetParentFolder();local copy = Utils.Table.Copy(self.m_nodes);local length = #copy;if length > 0 then;if length > 1 and copy[length] == "" then;copy[length] = nil;copy[length - 1] = "";else;copy[length] = nil;end;end;return Utils.String.Join(copy, "/");end;function Path:GetParentFolderPath();local copy = self:Copy();local length = #copy.m_nodes;if length > 0 then;if length > 1 and copy.m_nodes[length] == "" then;copy.m_nodes[length] = nil;copy.m_nodes[length - 1] = "";else;copy.m_nodes[length] = nil;end;end;return copy;end;function Path:GetFileName();if not self:IsFile() then;error("path is not a file: " .. self:GetPath());end;return self.m_nodes[#self.m_nodes];end;function Path:GetFileExtension();if not self:IsFile() then;error("path is not a file: " .. self:GetPath());end;local fileName = self.m_nodes[#self.m_nodes];local _, _, extension = fileName:find("^.+(%..+)$");return extension;end;function Path:GetFileStem();if not self:IsFile() then;error("path is not a file: " .. self:GetPath());end;local fileName = self.m_nodes[#self.m_nodes];local _, _, stem = fileName:find("^(.+)%..+$");return stem;end;function Path:Normalize();local newNodes = {};for index, value in ipairs(self.m_nodes) do;if value == "." then;elseif value == "" then;if index == 1 or index == #self.m_nodes then;newNodes[#newNodes + 1] = "";end;elseif value == ".." then;if index ~= 1 then;newNodes[#newNodes] = nil;end;else;newNodes[#newNodes + 1] = value;end;end;self.m_nodes = newNodes;return self;end;function Path:Append(path);path = formatStr(path);local newNodes = Utils.String.Split(path, "/");for _, value in ipairs(newNodes) do;self.m_nodes[#self.m_nodes + 1] = value;end;self:Normalize();return self;end;function Path:Extend(path);local copy = self:Copy();return copy:Append(path);end;function Path:Copy();local copyNodes = Utils.Table.Copy(self.m_nodes);return Path(copyNodes);end;return Utils.Class.CreateClass(Path, "Core.Path");local json = { _version = '0.1.2' };local encode;local escape_char_map = {;	['\\'] = '\\',;	['"'] = '"',;	['\b'] = 'b',;	['\f'] = 'f',;	['\n'] = 'n',;	['\r'] = 'r',;	['\t'] = 't';};local escape_char_map_inv = { ['/'] = '/' };for k, v in pairs(escape_char_map) do;	escape_char_map_inv[v] = k;end;local function escape_char(c);	return '\\' .. (escape_char_map[c] or string.format('u%04x', c:byte()));end;local function encode_nil(val);	return 'null';end;local function encode_table(val, stack);	local res = {};	stack = stack or {};;	if stack[val] then;		error('circular reference');	end;	stack[val] = true;	if rawget(val, 1) ~= nil or next(val) == nil then;;		local n = 0;		for k in pairs(val) do;			if type(k) ~= 'number' then;				error('invalid table: mixed or invalid key types');			end;			n = n + 1;		end;		if n ~= #val then;			error('invalid table: sparse array');		end;;		for i, v in ipairs(val) do;			table.insert(res, encode(v, stack));		end;		stack[val] = nil;		return '[' .. table.concat(res, ',') .. ']';	else;;		for k, v in pairs(val) do;			if type(k) ~= 'string' then;				error('invalid table: mixed or invalid key types');			end;			table.insert(res, encode(k, stack) .. ':' .. encode(v, stack));		end;		stack[val] = nil;		return '{' .. table.concat(res, ',') .. '}';	end;end;local function encode_string(val);	return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"';end;local function encode_number(val);;	if val ~= val or val <= -math.huge or val >= math.huge then;		error("unexpected number value '" .. tostring(val) .. "'");	end;	return string.format('%.14g', val);end;json.type_func_map = {;	['nil'] = encode_nil,;	['table'] = encode_table,;	['string'] = encode_string,;	['number'] = encode_number,;	['boolean'] = tostring;};encode = function(val, stack);	local t = type(val);	local f = json.type_func_map[t];	if f then;		return f(val, stack);	end;	error("unexpected type '" .. t .. "'");end;function json.encode(val);	return (encode(val));end;local parse;local function create_set(...);	local res = {};	for i = 1, select('#', ...) do;		res[select(i, ...)] = true;	end;	return res;end;local space_chars = create_set(' ', '\t', '\r', '\n');local delim_chars = create_set(' ', '\t', '\r', '\n', ']', '}', ',');local escape_chars = create_set('\\', '/', '"', 'b', 'f', 'n', 'r', 't', 'u');local literals = create_set('true', 'false', 'null');local literal_map = {;	['true'] = true,;	['false'] = false,;	['null'] = nil;};local function next_char(str, idx, set, negate);	for i = idx, #str do;		if set[str:sub(i, i)] ~= negate then;			return i;		end;	end;	return #str + 1;end;local function decode_error(str, idx, msg);	local line_count = 1;	local col_count = 1;	for i = 1, idx - 1 do;		col_count = col_count + 1;		if str:sub(i, i) == '\n' then;			line_count = line_count + 1;			col_count = 1;		end;	end;	error(string.format('%s at line %d col %d', msg, line_count, col_count));end;local function codepoint_to_utf8(n);;	local f = math.floor;	if n <= 0x7f then;		return string.char(n);	elseif n <= 0x7ff then;		return string.char(f(n / 64) + 192, n % 64 + 128);	elseif n <= 0xffff then;		return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128);	elseif n <= 0x10ffff then;		return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128, f(n % 4096 / 64) + 128, n % 64 + 128);	end;	error(string.format("invalid unicode codepoint '%x'", n));end;local function parse_unicode_escape(s);	local n1 = tonumber(s:sub(1, 4), 16);	local n2 = tonumber(s:sub(7, 10), 16);;	if n2 then;		return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000);	else;		return codepoint_to_utf8(n1);	end;end;local function parse_string(str, i);	local res = '';	local j = i + 1;	local k = j;	while j <= #str do;		local x = str:byte(j);		if x < 32 then;			decode_error(str, j, 'control character in string');		elseif x == 92 then;			res = res .. str:sub(k, j - 1);			j = j + 1;			local c = str:sub(j, j);			if c == 'u' then;				local hex = str:match('^[dD][89aAbB]%x%x\\u%x%x%x%x', j + 1) or str:match('^%x%x%x%x', j + 1) or;					decode_error(str, j - 1, 'invalid unicode escape in string');				res = res .. parse_unicode_escape(hex);				j = j + #hex;			else;				if not escape_chars[c] then;					decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string");				end;				res = res .. escape_char_map_inv[c];			end;			k = j + 1;		elseif x == 34 then;			res = res .. str:sub(k, j - 1);			return res, j + 1;		end;		j = j + 1;	end;	decode_error(str, i, 'expected closing quote for string');end;local function parse_number(str, i);	local x = next_char(str, i, delim_chars);	local s = str:sub(i, x - 1);	local n = tonumber(s);	if not n then;		decode_error(str, i, "invalid number '" .. s .. "'");	end;	return n, x;end;local function parse_literal(str, i);	local x = next_char(str, i, delim_chars);	local word = str:sub(i, x - 1);	if not literals[word] then;		decode_error(str, i, "invalid literal '" .. word .. "'");	end;	return literal_map[word], x;end;local function parse_array(str, i);	local res = {};	local n = 1;	i = i + 1;	while 1 do;		local x;		i = next_char(str, i, space_chars, true);;		if str:sub(i, i) == ']' then;			i = i + 1;			break;		end;;		x,;		i = parse(str, i);		res[n] = x;		n = n + 1;;		i = next_char(str, i, space_chars, true);		local chr = str:sub(i, i);		i = i + 1;		if chr == ']' then;			break;		end;		if chr ~= ',' then;			decode_error(str, i, "expected ']' or ','");		end;	end;	return res, i;end;local function parse_object(str, i);	local res = {};	i = i + 1;	while 1 do;		local key,;		val;		i = next_char(str, i, space_chars, true);;		if str:sub(i, i) == '}' then;			i = i + 1;			break;		end;;		if str:sub(i, i) ~= '"' then;			decode_error(str, i, 'expected string for key');		end;		key,;		i = parse(str, i);;		i = next_char(str, i, space_chars, true);		if str:sub(i, i) ~= ':' then;			decode_error(str, i, "expected ':' after key");		end;		i = next_char(str, i + 1, space_chars, true);;		val,;		i = parse(str, i);;		res[key] = val;;		i = next_char(str, i, space_chars, true);		local chr = str:sub(i, i);		i = i + 1;		if chr == '}' then;			break;		end;		if chr ~= ',' then;			decode_error(str, i, "expected '}' or ','");		end;	end;	return res, i;end;local char_func_map = {;	['"'] = parse_string,;	['0'] = parse_number,;	['1'] = parse_number,;	['2'] = parse_number,;	['3'] = parse_number,;	['4'] = parse_number,;	['5'] = parse_number,;	['6'] = parse_number,;	['7'] = parse_number,;	['8'] = parse_number,;	['9'] = parse_number,;	['-'] = parse_number,;	['t'] = parse_literal,;	['f'] = parse_literal,;	['n'] = parse_literal,;	['['] = parse_array,;	['{'] = parse_object;};parse = function(str, idx);	local chr = str:sub(idx, idx);	local f = char_func_map[chr];	if f then;		return f(str, idx);	end;	decode_error(str, idx, "unexpected character '" .. chr .. "'");end;function json.decode(str);	if type(str) ~= 'string' then;		error('expected argument of type string, got ' .. type(str));	end;	local res,;	idx = parse(str, next_char(str, 1, space_chars, true));	idx = next_char(str, idx, space_chars, true);	if idx <= #str then;		decode_error(str, idx, 'trailing garbage');	end;	return res;end;return json;local Json = require("Core.Json.Json");local JsonSerializer = {};JsonSerializer.Static__Serializer = Utils.Class.Placeholder;function JsonSerializer:__init(typeInfos);self.m_typeInfos = {};for _, typeInfo in ipairs(typeInfos or {}) do;self.m_typeInfos[typeInfo.Name] = typeInfo;end;end;function JsonSerializer:AddTypesFromStatic();for name, typeInfo in pairs(self.Static__Serializer.m_typeInfos) do;if not Utils.Table.ContainsKey(self.m_typeInfos, name) then;self.m_typeInfos[name] = typeInfo;end;end;end;function JsonSerializer:AddTypeInfo(typeInfo);if not Utils.Class.HasTypeBaseClass("Core.Json.Serializable", typeInfo) then;error("class type has not Core.Json.Serializable as base class", 2);end;if not Utils.Table.ContainsKey(self.m_typeInfos, typeInfo.Name) then;self.m_typeInfos[typeInfo.Name] = typeInfo;end;return self;end;function JsonSerializer:AddTypeInfos(typeInfos);for _, typeInfo in ipairs(typeInfos) do;self:AddTypeInfo(typeInfo);end;return self;end;function JsonSerializer:AddClass(class);return self:AddTypeInfo(typeof(class));end;function JsonSerializer:AddClasses(classes);for _, class in ipairs(classes) do;self:AddClass(class);end;return self;end;function JsonSerializer:serializeClass(class);local typeInfo = typeof(class);local data = { __Type = typeInfo.Name, __Data = { class:Serialize() } };local max = 0;for key, value in next, data.__Data, nil do;if key > max then;max = key;end;end;for i = 1, max, 1 do;if data.__Data[i] == nil then;data.__Data[i] = "%nil%";end;end;if type(data.__Data) == "table" then;for key, value in next, data.__Data, nil do;data.__Data[key] = self:serializeInternal(value);end;end;return data;end;function JsonSerializer:serializeInternal(obj);local objType = type(obj);if objType ~= "table" then;if not Utils.Table.ContainsKey(Json.type_func_map, objType) then;error("can not serialize: " .. objType .. " value: " .. tostring(obj));return {};end;return obj;end;if Utils.Class.HasBaseClass(obj, "Core.Json.Serializable") then;return self:serializeClass(obj);end;for key, value in next, obj, nil do;if type(value) == "table" then;rawset(obj, key, self:serializeInternal(value));end;end;return obj;end;function JsonSerializer:Serialize(obj);return Json.encode(self:serializeInternal(obj));end;local function isDeserializedClass(t);if not t.__Type then;return false;end;if not t.__Data then;return false;end;return true;end;function JsonSerializer:deserializeClass(t);local data = t.__Data;local typeInfo = self.m_typeInfos[t.__Type];if not typeInfo then;error("unable to find typeInfo for class: " .. t.__Type);end;local classTemplate = typeInfo.Template;if type(data) == "table" then;for key, value in next, data, nil do;if value == "%nil%" then;data[key] = nil;end;if type(value) == "table" then;data[key] = self:deserializeInternal(value);end;end;end;return classTemplate:Static__Deserialize(table.unpack(data));end;function JsonSerializer:deserializeInternal(t);if isDeserializedClass(t) then;return self:deserializeClass(t);end;for key, value in next, t, nil do;if type(value) == "table" then;t[key] = self:deserializeInternal(value);end;end;return t;end;function JsonSerializer:Deserialize(str);local obj = Json.decode(str);if type(obj) == "table" then;return self:deserializeInternal(obj);end;return obj;end;function JsonSerializer:TryDeserialize(str, outObj);local success, _, results = Utils.Function.InvokeProtected(self.Deserialize, self, str);outObj.Value = results[1];return success;end;Utils.Class.CreateClass(JsonSerializer, "Core.Json.JsonSerializer");JsonSerializer.Static__Serializer = JsonSerializer();JsonSerializer.Static__Serializer:AddClass(require("Core.Common.UUID"));return JsonSerializer;local Serializable = {};function Serializable:Serialize();local typeInfo = typeof(self);error("Serialize function was not override for type " .. typeInfo.Name);end;function Serializable:Static__Deserialize(...);return self(...);end;return Utils.Class.CreateClass(Serializable, "Core.Json.Serializable");local Config = require("Core.Config");local IReference = {};IReference.m_expires = 0;function IReference:Get();if self.m_expires < computer.millis() then;if not self:Fetch() then;return nil;end;self.m_expires = computer.millis() + Config.REFERENCE_REFRESH_DELAY;end;return self.m_obj;end;function IReference:Fetch();error("cannot call abstract method IReference:Fetch");end;function IReference:Check();return self:Get() == nil;end;return Utils.Class.CreateClass(IReference, "Core.IReference");local PCIDeviceReference = {};function PCIDeviceReference:__init(class, index);self.m_class = class;self.m_index = index;end;function PCIDeviceReference:Fetch();local obj = computer.getPCIDevices(self.m_class)[self.m_index];self.m_obj = obj;return obj ~= nil;end;return Utils.Class.CreateClass(PCIDeviceReference, "Core.PCIDeviceReference",;require("Core.References.IReference"));local ProxyReference = {};function ProxyReference:__init(id);self.m_id = id;end;function ProxyReference:Fetch();local obj = component.proxy(self.m_id);self.m_obj = obj;return obj ~= nil;end;return Utils.Class.CreateClass(ProxyReference, "Core.ProxyReference",;require("Core.References.IReference"));return {;Ports = require("Core.Usage.Usage_Port"),;Events = require("Core.Usage.Usage_EventName");};local EventNameUsage = {;DNS_Heartbeat = "DNS",;DNS_GetServerAddress = "Get-DNS-Server-Address",;DNS_ReturnServerAddress = "Return-DNS-Server-Address",;RestRequest = "Rest-Request",;RestResponse = "Rest-Response",;FactoryControl_Heartbeat = "FactoryControl",;FactoryControl_Feature_Update = "FactoryControl-Feature-Update",;CallbackService = "CallbackService",;CallbackService_Response = "CallbackService-Response";};return EventNameUsage;local PortUsage = {;;	DNS_Heartbeat = 10,;	DNS = 53,;	HTTP = 80,;;	FactoryControl_Heartbeat = 1250,;	FactoryControl = 1251,;;	CallbackService = 2400,;	CallbackService_Response = 2401,;};return PortUsage;